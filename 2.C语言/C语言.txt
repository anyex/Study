1. 二进制
		计算机中用补码表示一个数，其中非负补码和源码相同
		负数是取反后加1
  
  
  
2. ASCII 码     
		   每个字符是一个编码范围在0-127
           a-z 小写字母的编码是 97-122
		   A-Z                  65-90
		   0-9                  48-57
		   \0(空)                   0
		   ‘ ’(空格)			32
		   
		   字符当整数使用时，使用的是ASCII码的数值
	        'A'-'Z' = 65-90	   
3. 计算机内存
	
		计算机管理内存以字节为单位，1byte=8bit
		汉字是使用GB2312编码，一个汉字是两个字节


4.常用数据类型
		
		int   4字节=32位，1byte=8bit  第一位表示正负,后面的表示数值，2^31-1 ,-2^31（因为最高为是2^31）
		
		long  4字节   
		float 4字节
		short 2字节
		
		float 4字节
		    其组成为
			     符号位          阶码            尾数
	               1               8              23
		double 8字节
				 符号位          阶码            尾数
				   1               11              52
	    可用sizeof() 函数获取字节大小
		
5.数据溢出
		
		当要表示的数据超出数据类型所能表示的范围就会溢出
		整数会导致回绕
		小数会变无穷

6.数据类型自动提升
	    对数据进行运算的时候会按以下规则进行计算
		
		  短整型向长整型看齐，有符号向无符号看齐，整形向浮点型看齐，单精度向双精度看齐
	      详见C语言/01.c
		 
7.格式输出
		%g   输出实数，根据数值大小自动选择用f(浮点)还是e(科学计数法)
        %d   int
		%s   字符串
		%u   unsigned int
		%i   将输入的八进制或十六进制转换为十进制再输出
		%c   char
		%ld  long
		%hd  short int
		%x   十六进制
		%o   八进制
		%p   指针
		%f   float
		%lf  double //会去掉尾数0
		
		
		
		详细见02.c
8.宏定义
	宏即替换，可以用宏定义的内容进行替换
	如#define PI 3.14
	  那么在程序中PI就会在预编译的时候被替换成3.14
	
	
9.逻辑运算符
	&&：与   a&&b    a,b同时为真菜为真
	||: 或   a||b    a,b同时为假才为假
	！：非   
	
    运算符优先级
		!>算术运算符>关系运算符(>,<,==)>||>赋值运算符
		
10.位运算符
		可以对内存中的某一位进行操作
		  &:相同位的两个数字都为1，则为1，否则为0	
			1&x = x    0&x = 0
		  |:相同位有一个为1，则为1，否则为0
		  
		  ^:异或，相同位不同为1，相同为0
		  ~:非，即取反
		  
		  << 左移，2<<2  ==> 10<2 ==>1000 = 8   a<<b 即 a*2^b  
		  >> 右移，8>>2  ==> 1000>>2 = 10=2     a>>b 即 a/2^b
		  
			
11. &与*
	&:取地址运算符
	*:根据地址取数值
	

12  ?:
    如 a的绝对值可以表示为 a<0?-a:a 
	
	详见C语言/03.c
	   

13  比较小数
		小数使用的是近似值，所以比较小数的时候只是比较他们相似，并不是绝对相等
	    可以使用 fabs(a-b) <1E-5差多少
		详细见04.c
		
14  scanf与printf
		
		printf:计算顺序从左到右
		 如 printf("%d,%d,%d",i++,i++,i++);//输出为2,1,0,
		 
		scanf("格式符",地址表);	
		   scanf中如果有空白字符，直到遇到非空白字符才读取
		   当scanf中有%c的时候一定要在前面加上一个空格
		   scanf中返回值是成功读取了多少字符
		   scanf中只要格式占位符，如果scanf中有空白字符，将跳过所有空白字符，直到遇见非空白字符
		
		注:	
		  
		scanf是从缓存区里读取数据，如果输入的数据多了会留在缓冲区等待下一次使用，不会丢弃
		而且如果输入的字符和格式符不对应，这个字符就不会被取走，一直留在缓存
		
		可以使用scanf("%*[^\n]%*c")清除缓冲区剩余的字符
		
	    详细见程序05.c
		
15  分支，循环(略)

16  枚举常量
	  enum bool {true=1,flase=0,abc};
	     其中true，false即枚举常量，默认从0开始，后面一个都是前一个加1，此处abc=1
		 enum aff{a,b,c};则a=0,b=1,c=2;
		 
17  typedef
		为一个类型定义一个方便使用的标签
		如 typedef int INTERGER,可以使用INTERGER来代替int

18  数组
	   
	   1)概念：
	   
	        即一块固定大小的连续空间
			如int a[8];即分配了一块连续的可以保存8个整数的空间
			
	   2)定义：
			声明的时候必须指定数组的大小，即可以包容的元素个数
		
			元素个数可以是宏定义的常量，但不能是变量
			 如 int a[3];
			    char b[8];
				float c[20];
			数组名是一个常量，只是代表一个数据(数组的首地址)
			
	   3)赋值：
	   
			可以在定义时，初始化赋值 int a[5] = {1,2}
			可以直接对某一个元素赋值  a[1] = 3;
		    可以使用scanf函数输入赋值 如 scanf("%d",a[1]);
                                         scanf("%d",a+1);
										 
	   4)引用数组的值
	        
			 int b = *(a+2);int b = a[2] 都能实现将a[2]的值用b读取出来
			 
	   5)字符数组
			
		    字符串都是以'\0'结尾.则prinf("%s",str);都是输出到'\0'就停止输出		
			
	   6)字符串处理系列函数
				
			#include <string.h>
			
			strcpy(char *a,char *b) 将数组b复制到数组a
			puts(a)                 输出字符串a
			strchr(a,'f')			在字符串a中寻找f字符，找到返回这个字符的地址，否则返回空指针(从左向右找)
			strlen(a)				求字符串a的长度，即有多少字符，不包括'\0'
			
			详细见程序06.c
			
			
	   7)二维数组
	       二维数组也是连续存储的一个连续空间
		   它是先放入a[0]行，再放入a[1]行......即a[i][0]指向第i行
		   每行的元素也是按顺序存放
		    
	      
		   
		    
19  结构
	   结构体的定义方式
	      typedef struct person{
		      char name[20];
			  int age;
			  double income;
			  
		  
		  }person;
		  
		  1))typedef:为一个数据类型定义一个新名字,此处是将结构体 struct person定义为person，即person 等价于struct person
		  2))name,age,income，s是成员变量，可以定义为任何基本数据类型和自定义数据类型;
          3))结尾处person为结构体变量，可以直接用person再次定义其它结构体变量，如person a,person b;
          4))结构体变量的初始化方法： 
                             person b ={"diao 24",MALE,18,8005};
                             person c ={age:18,s:FEMALE,name:"fu rong",income:9876.5};
              两者都能正确的初始化结构体变量
 
          2).结构体员的引用：
                       如引用a的成员变量 a.s，a.name，.只能访问基本类型。
                       如果是结构体中包含有结构体应该用多次用.访问，直到访问到基本数据类型
          3).结构体数组：
                        person p[5] = {a,b,c,d,{"zheng xiaosan",MALE,44,8005}};对其操作方法和数组没有区别


		  
	   
	   结构体的对齐和补齐  
			1.数据成员对齐规则：
			    1)第一个数据成员存放在为0的位置，结构的数据成员，存放的初始位置必须为该数据类型的整数倍
		      	  如short 必须为2的倍数，int必须为4的倍数 ，double为4的倍数(超过4的按4的倍数计算)
                2)结构体内有结构体成员，这个成员要从其内部的最大元素大小的整数倍大小存储
            2.补齐 
			    3)结构体的总大小，必须是其内部最大成员的整数倍(超过4，按4的倍数计算)，不足要补齐

                 详细见程序07.c


       联合体
		
		  可以使用union来定义
		     
			  union 联合体{
			     成员列表
			     
			  }；
			  
		   联合体的所有成员占用同一段内存，修改一个成员会影响其余所有成员
		   联合体的内存大小等于最长的成员所占用的内存
		   联合体会内存覆盖，同一时刻只能保存一个成员的值，如果对新的成员赋值就会把原来的成员覆盖
		  
		  详细见08.c
		  
	

20.函数
   
      1.函数主要包括声明，定义，调用3个过程
          声明：即说明函数的形式(返回值，参数，函数名)		
		  定义：实现声明的函数的功能
		  调用：调用函数，完成一个功能
		  
		  
		#include<stdio.h>
			void clear();//函数的声明.可以在多个地方声明,但是定义只有一份,必须唯一.
		int main()
		{		
				char name[20];
                char gender;
                printf("请输入姓名:");
                scanf("%s",name);
                printf("请输入性别:");
                clear();//函数的调用,调用的原则在那里调用,完成后返回那里.
                scanf("%c",&gender);
                printf("%s:%c\n",name,gender);
                return 0;
        }
			void clear//函数的定义
			{
				scanf("%*[^\n]");
				scanf("%*c");
			}
			
			
	  2.函数参数传递
            1） C语言的参数传递都是传递值的拷贝
			 
			2） 传指针也是把指针值按拷贝传递进去，因为指针指向一块外部内存空间
			    所以可以在函数内部改变外部的变量，从而穿进去的往往是指针变量的指针
				     
				
			
			        其形式见程序/10	
			
			3） 不定长函数参数,用以下几个参数来处理
					va_list v   //定义v
					va_start(v,cnt) //用v保存从参数cnt之后的参数表
					va_arg(v,int)   //从参数表v中读取一个int类型
					va_end(v)       //释放参数列表
					
				 详见C语言/11可变参数函数
					
         
21.变量的作用域
		static :声明静态变量，程序不退出将一直存在
		        但作用域依然限制到定义的函数体范围内
				
		extern :定义一个全局变量在函数体外，声明时，不能赋值
		        全局变量的生命周期等同于程序执行时间，程序开始时，全局变量将被执行初始化
				全局变量可以被工程项目中的任何文件与函数访问
				在定义全局变量的c文件中，无需声明就可以使用该变量，其他c文件中,只需要使用extern声明
			      
                  详细见程序\extern\09.c,09.h
				  
				
		register:寄存器数据，请求编译器将变量放到寄存器，不放到内存中，有可能成功
		         因为被放在寄存器，不在内存中，所以不能被取地址
		
		volatile:修饰被不同线程访问和修改的变量，确保本条指令不会因编译器的优化而省略
		         且要求每次读值
				 
				 
22. realloc,malloc,calloc的使用
   
      calloc:
	     void* calloc(size_t n,size_t size);
		 在内存的动态存储区中分配n个长度为size的连续空空间
		 函数返回一个指向分配起始地址的指针，不成功返回NULL
		 calloc在动态分配完内存后，自动初始化该空间为零   
		 
		 
	  malloc:
		 void *malloc(unsigned int num_bytes)
		 用于申请一块连续的指定大小为num_bytes的内存区域
		 返回指向内存起始地址的指针
		 它在分配完内存后，不会初始化，是一堆垃圾数据
		 
	  realloc:
	     
		  void *realloc(void* ptr,size_t size);
		  重新设定已分配内存区域的内存块的大小，并将原内存区的数据复制到这个空间，但是会重新开启一块新内存
		  
		  
23.sscanf,sprintf
    
	 sscanf: int sscanf (const char *str,const char * format,........);
	    会将str参数的字符串根据format字符串来转换并格式化数据
	    成功返回正确格式化数据的个数
	 sprintf:int sprintf( char *buffer, const char *format, [ argument] … );
	         将格式化的数据写入某个字符串



24 C文件操作
     常用函数
	   1)打开文件
     	  File *fopen(char *pname,char *mode);
		  pname :文件名
		  mode  :打开文件的方式（r,w,a,r+,w+,a+）
	   2)关闭文件
           int fclose(FILE *fp)
		   fp是一个已打开的文件的指针
	   3) 读取一个字符
	        int fgetc(FILE *fp),从fp中读取一个字符，作为返回值返回
	   4）写一个字符到文件中
	        int fputc(int ch,FILE* fp)
			  ch:要写到文件的字符
			  fp:文件指针，要写入的文件
	   5）从文件读取一个字符串
	        char *fgets(char* str,int n,FILE* fp)
			从fp指向的文件读出n-1个字符，并把他们存放到有str指出的字符数组分区,并在末尾加上'\0'
			正常:返回字符串的首地址，错误返回一个NULL，可以用feof()或ferror()来判断是否读取到末尾还是发生了错误
			
			
			
	   6）写入字符串到文件中去
			int fputs(const char* str,FILE* stream)
			把由str指向的字符串写入到fp所指的文件中去
			
			str:要写入到文件中的字符串，不包括最后的'\0'
			fp: 文件指针，要写入的文件
			
			返回值：写入到文件的字符个数，即字符串的长度
			非正常返回: 返回一个NULL值
	   7）往文件中写格式化数据
			 int fprintf(FILE *fp,char* format,arg_list)
			 将变量表列(arg_list)中的数据,按照format指出的格式，写入到fp指定的文件
	         
			 fp:文件指针，要写入的文件
			 format:格式串，与printf的格式串相同
			 arg_list:要写入文件的变量列表，各变量之间用逗号分隔
	
	   8）以二进制形式读取文件中的数据
            int fread(void* buffer,size_t size,size_t count,FILE* stream)
            从由fp指定的文件中，按二进制形式将size*count个数据读到buffer指出的数据区中
			
			buffer :接收数据的内存地址
			size:要读取的每个数据项的字节数
			count: 读count个数据项，每个数据项size个字节
			stream:输入流(文件指针)
			返回真实读取的项数
	   9）以二进制形式写数据到文件中
	   
	         size_t fwrite(const void* buffer,size_t size,size_t count,FILE* stream)
			 按二进制的形式将由buffer指定的数据缓冲区中的size*count个数据写入由fp指定的文件中去
			 
	  10) 文件状态检查
			
			int feof(FILE* fp)
			判断文件是否结束，
			返回0，文件未结束
			返回1，文件结束
	  11) 文件指针的当前位置
	        long ftell(FILE* fp)
			取得fp指定文件的当前读/写位置，该位置用相对于文件开头的位移量来表示
			fp:文件指针
	  12) 文件定位
	  
	       void rewind(FILE* fp)
		   使文件指针fp指定的文件的位置指针重新指向文件的开头位置
	  13) 随机定位
			int fseek(FILE* fp,long offset,int base)
			使文件指针移动到基于base的相对位置offset处
		
	  14) exit()
	        
			void exit(int status)
			exit()函数使程序立即终止执行，同时将缓冲区中剩余的数据输出并关闭所有已经打开的文件
	  
	  
	  
	  详细用法
	     见程序/C文件操作

		 

25 指针专题

	  1.指针解析
		int p  			普通的整型
		
		int *p  		p先与*结合，所以p是一个指针，然后再与int结合，说明指针指向的内容为int
						即p是一个指向整数类型的指针
				
		int p[3] 		p先与[]结合，说明p是一个数组，然后与int结合，说明数组里面的元素是整型的
						即p是一个由整型数据组成的数组
		
		int *p[3]       首先从p处开始，先与[]结合，因为其优先级比*高，所以p是一个数组，所以p是一个数组，然后再与int *结合
		                说明p是一个指针，所以p是一个由整型数据的指针所组成的数组
		
		int (*p)[3]     从P处开始,先与*结合，说明p是一个指向由整型数据组成的数组的指针
		
		int **p         p先与*结合，所以p是一个指针，然后再与*结合，说明该指针指向的元素仍然是指针，最后与
						int 结合，说明该指针所指向的元素是整型数据。
		
		int p(int)      从p处起，先与()结合，说明p是一个函数，然后进入()，说明函数有一个整型变量的参数
						然后再与外部的int结合，说明函数的返回值是一个整型数据
		
		int(*p)(int)    从p处开始，先与指针结合，说明p是一个指针，然后与()结合，说明指针指向的是一个函数
						然后再与()里的int结合,说明函数的返回类型是整型，所以p是一个指向整型参数且返回类型为整型的函数的指针
						
		int *(*p(int))[3]  从p开始，先与()结合，说明p是一个函数，然后进入()里面，与int结合，说明函数有一个整型变量参数
							然后再与外面的*结合，说明函数返回的是一个指针，然后到最外面一层，先与[]结合，说明返回的是一个数组
						    然后再与*结合，说明数组里的元素是指针，然后再与int结合，说明指针指向的内容是整型数据
							即，p是一个参数为整数，且返回一个指向整型指针变量组成的数组的指针变量的函数
					
	 
	 
	 
	 2.指针概念
			指针是一个特殊的变量，它里面存储的数值被解释为内存里的一个地址
			指针的几个特性：
			
			
			    1)指针的类型:去掉指针声明语句里的指针的名字，剩下的部分就是这个指针的类型
								如int *ptr   //类型为int*
								  char* ptr  //类型为char*
					
							
				2)指针所指向的类型:
				          指针指向的类型决定了编译器怎么看待指针指向的内存区的内容
						    如：int* ptr //指针指向的类型是int
							    char* ptr //指针指向的类型为char
								int** ptr //指向的类型为int*
				
						     
							
				3)指针的值(指向的内存区):
						  指针的值是本身存储的值，这个值将被编译器当做一个地址。在32位程序里，
						  所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全是32位字长。
						  指针所指向的区域就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针指向的类型)
				
				
				4)指针本身所占据的内存区
				           指针本身只是一个地址，32位程序里面都只占用4各字节
						   指针本身占据的内存可以用来判断是否是左值
						   
	 3.指针的算术运算
			
			指针可以加上或减去一个整数，加减改变的地址位置，以指向的数据类型为单位
	
	         如 char a[20];
				int* ptr = (int *)a；
				ptr++;
			
			指针ptr的类型为int* ，它指向的类型是int，它被初始化为指向整型变量a,ptr++意味着它指向的地址将右移sizeof(int)字节
		    
			即：一个指针ptrold加减一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold相同
				ptrnew所指向的类型也和ptrold指向的类型相同。
				ptrnew的值将比ptrold的值增加(减少)了n*sizeof(ptrold指向的类型)
				
			指针和指针不能进行相加，可以进行相减(类型必须相同)
	 
	 
	 4.运算符&和*
			&是取地址运算符，*是间接运算符
			&a的运算结果是一个指针，指针的类型是a的类型再加个*,指针所指向的类型是a的类型，指针指向的地址就是a的地址
			
			*p就是p所指向的内容，它的类型是p指向的类型，它占用的地址就是p所指向的地址
	
	
	 5.指针表达式
		
			一个表达式的结果如果是一个指针，那么这个表达式就叫指针表达式
			
			如: int a,b;
				int array[10];
				int* pa;
				pa=&a;
				int **ptr =&pa
				
			
	 6.数组和指针的关系
			
			数组的数组名可以看做一个指针。
			int array[10] = {0,1,2,3,4,5,6,7,8,9},value;
	        value = array[0];//也可以记做 value = *array		
			
			数组名array代表数组本身，类型是int[10],如果把它视作指针，它指向数组的第0个单元
			类型是int*，所指向的类型是数组单元的类型即int。同理array+2指向数组的第2个单元
			
							
		    故：1)数组名可以代表数组本身，如sizeof(array) = 40
			    2)数组名可看做数组第0个元素的指针
	 7.指针和结构类型的关系
	     
	        #include "stdio.h"
  2         
  3         typedef struct MyStruct
  4         {
  5            int a;
  6            int b;
  7            int c;
  8            char d;
  9         }A;
 10         
 11         
 12         
 13         int main()
 14         {
 15                 A ss = {20,30,40,'A'};
 16                 A *ptr = &ss;
 17                 int *pstr = (int*)&ss;
 18         
 19                 printf("ss.a = %d,pstr获取a = %d\n",ptr->a,*pstr);
 20                 printf("ss.b = %d,pstr获取b = %d\n",ptr->b,*(pstr+1));
 21         
 22                 return 0;
 23         
 24         }
            
				//虽然通过*(pstr+1)能获取到结构体对于的成员，但是因为结构体的补齐对齐，可能会出现获取错误的情况
				  应该使用ptr->a，或(*ptr).a的方式访问结构体成员
				  
      8  指针和函数的关系
	       可以把一个指针声明成一个指向函数的指针
            int fun1(char* ,int)
			int (*pfun1) (char*,int)
			pfun1 = fun1;
			
		   int a = (*pfun1)("abcdef",7);//通过函数指针调用函数
		   
		   可以把指针作为函数的相参，在函数调用语句中，可以用指针表达式来作为实参
		   
		   如下面程序所示：
		    
			
			    #include "stdio.h"

				int (*pfun)(char*);//定义函数指针
				int fun(char*);

                int fun(char* s)
                {
                   int num = 0;
                   for(int i = 0;*s!='\0';)
                	{
                	  num+=*s;s++;
                	}
                   return num;
                }
                
                int main()
                {
                
                char s[] = "afasdfadsgdasf";		
                  pfun = fun;//函数指针指向fun
                  int a = (*pfun)(s);//相当于调用pfun
                  printf("%d",a);
                
                  return 0;
                }
				
				
	   9  指针类型转换
               初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式
			   如果要为一个指针变量赋值不同类型的值就要使用强制类型转换
			   
			   即，如有指针p，需要把它的类型和所指向的类型改为TYPE *，那么语法格式为(TYPE *)pa
			   如：int a=125,b；
			       char c;
			       a = (int*)c;
				   
				  还可以直接对指针赋值一个地址
						int *a ;
						
						a = (int*)0x123f
				
			     int a=123,b; 
				 int* ptr=&a;
				 char* str;
				 b=(int)str;//把指针ptr的值当做一个整数取出来
				 str=(char*)b//把这个整数的值当做一个地址赋值给指针str
				 
				 
				
				
				
				
				
				
		
				
				


















































  1 
				
				
				
				
				
	  
     
				 
		
		
		
     		
		  
	
			
		
			
		    
		
		
			
			
			
			
			
			
		
		